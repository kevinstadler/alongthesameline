{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["circleStyle","VectorLayer","getStyle","circleStyleFunction","feature","resolution","get","setText","Text","stroke","getStroke","fill","getFill","text","Math","round","rotation","rotateWithView","offsetX","getRotation","points","dx","dy","atan2","arrowStyle","geom","getGeometry","getCoordinates","length","Style","geometry","Point","image","RegularShape","radius","angle","PI","getImage","App","props","fitGreatCircle","numSegments","GreatCircle","x","y","Arc","offset","geometries","generateGreatCircle","extent","map","getView","calculateExtent","unitsPerPixel","getWidth","getSize","pointSource","getFeatures","c","toLonLat","antipodes","sign","pointGroups","nSegments","sqrt","pow","d","min","max","ceil","newFeatures","i","arc","Feature","LineString","coords","fromLonLat","flat","metersPerPixel","getProjection","getMetersPerUnit","markerEvery","log10","segmentLength","getDistance","nSegmentsToGetOneEveryMarker","markerFeatures","arcpoint","start","end","markerLine","sin","cos","label","greatCircleSource","clear","setStyle","addFeatures","componentDidMount","draw","Draw","source","type","maxPoints","on","view","View","center","zoom","projection","Map","layers","TileLayer","XYZ","url","attributions","tileSize","maxZoom","crossOrigin","style","target","interactions","defaultInteractions","extend","Modify","insertVertexCondition","never","Snap","render","id","VectorSource","React","Component","Boolean","window","location","hostname","match","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.8f1e041c.chunk.js","sourcesContent":["import React from 'react';\nimport './App.css';\nimport 'ol/ol.css';\n\nimport Map from 'ol/Map.js';\nimport View from 'ol/View.js';\n\nimport {defaults as defaultInteractions, DragRotateAndZoom, Draw, Modify, Snap} from 'ol/interaction';\nimport {never} from 'ol/events/condition';\n\nimport {Tile as TileLayer, Vector as VectorLayer} from 'ol/layer';\nimport {OSM, Vector as VectorSource, XYZ} from 'ol/source';\nimport Feature from 'ol/Feature';\nimport MultiPoint from 'ol/geom/MultiPoint';\nimport Point from 'ol/geom/Point';\nimport LineString from 'ol/geom/LineString';\nimport {Fill, Stroke, Circle, Style} from 'ol/style';\nimport Text from 'ol/style/Text';\nimport RegularShape from 'ol/style/RegularShape';\n\nimport {GreatCircle} from 'arc';\nimport {getDistance} from 'ol/sphere';\nimport {fromLonLat, toLonLat} from 'ol/proj.js';\nimport {containsExtent, getHeight, getWidth} from 'ol/extent';\n\nconst viewProjection = 'EPSG:4326';\n\nconst circleStyle = new VectorLayer().getStyle()()[0];\n\nconst circleStyleFunction = (feature, resolution) => {\n  if (feature.get('label')) {\n    circleStyle.setText(new Text({\n      stroke: circleStyle.getStroke(),\n      fill: circleStyle.getFill(),\n      text: Math.round(feature.get('label') / 1000) + ' km',\n      rotation: feature.get('rotation'),\n      rotateWithView: true,\n      offsetX: 25,\n    }));\n  }\n  return circleStyle;\n}\n\nconst getRotation = (points) => {\n  const dx = points[0][0] - points[1][0];\n  const dy = points[0][1] - points[1][1];\n  return Math.atan2(dy, dx);\n}\n\nconst arrowStyle = (feature) => {\n  const geom = feature.getGeometry().getCoordinates();\n  const rotation = getRotation([geom[geom.length - 1], geom[geom.length - 2]]);\n  return [\n    circleStyle,\n    new Style({\n      geometry: new Point(geom[geom.length - 1]),\n      image: new RegularShape({\n        stroke: circleStyle.getStroke(),\n        points: 3,\n        radius: 8,\n        rotation: -rotation,\n//        displacement: [ -4 * Math.sin(rotation), 4 * Math.cos(rotation) ],\n        angle: Math.PI / 2\n      })\n    }),\n    new Style({\n      geometry: new Point(geom[0]),\n      image: circleStyle.getImage()\n    })\n  ];\n}\n\nclass App extends React.Component {\n\n  constructor(props) {\n    super(props);\n\n    this.pointSource = new VectorSource();\n    this.greatCircleSource = new VectorSource();\n  }\n\n  fitGreatCircle = (points, numSegments) => {\n    // TODO catch TypeError/Error when two points are antipodal\n    const generator = new GreatCircle({ x: points[0][0], y: points[0][1] }, { x: points[1][0], y: points[1][1] });\n    return generator.Arc(numSegments, { offset: 0.1 }).geometries; // 1 or more arc segments (split at +-180deg)\n  }\n\n  generateGreatCircle = () => {\n    // in projection coordinates (because number of segments will depend on pixels)\n    const extent = this.map.getView().calculateExtent();\n    const unitsPerPixel = getWidth(extent) / this.map.getSize()[0];\n\n    const points = this.pointSource.getFeatures()[0].getGeometry().getCoordinates().map((c) => toLonLat(c, viewProjection));\n    const antipodes = points.map(([x, y]) => [x - 180*Math.sign(x), -y]);\n    const pointGroups = [\n      points,\n      [ points[1], antipodes[0] ],\n      antipodes,\n      [ antipodes[1], points[0] ],\n    ];\n    // TODO skip segments which aren't visible in the current view?\n\n    // TODO calculate great circle distance between those points, and choose number of segments accordingly?\n    const pixelDistances = pointGroups.map((c) => Math.sqrt(\n      Math.pow(c[0][0] - c[1][0], 2)\n      + Math.pow(c[0][1] - c[1][1], 2)) / unitsPerPixel);\n    // don't leave the 1, 1000 segment range\n    const nSegments = pixelDistances.map((d) => Math.min(1000, Math.max(1, Math.ceil(d / 20))));\n\n    const newFeatures = pointGroups.map((points, i) => {\n      return this.fitGreatCircle(points, nSegments[i]).map((arc) => new Feature({\n        geometry: new LineString(arc.coords.map((c) => fromLonLat(c, viewProjection)))\n  //        style: new Style(),\n      }));\n    }).flat();\n\n    const metersPerPixel = unitsPerPixel * this.map.getView().getProjection().getMetersPerUnit();\n    // draw a distance marker every 10 pixels\n    var markerEvery = Math.ceil(Math.log10(10 * metersPerPixel));\n    // convert to meters\n    markerEvery = Math.pow(10, markerEvery); // TODO allow markers at 5s as well as 1s\n    // TODO find currently visible segment from the previously fit great circles, then\n    // 1. find 90degree (or smaller) point, figure out how many segments would produce points\n    // at every required multiple of meters\n    const segmentLength = getDistance(pointGroups[1][1], pointGroups[1][0]); // point to antipode\n    const nSegmentsToGetOneEveryMarker = Math.ceil(segmentLength / markerEvery);\n    const markerBasis = this.fitGreatCircle(pointGroups[1], nSegmentsToGetOneEveryMarker);\n    // 2. fit a new, short 1-segment linestring through every of those points, at the mean angle of\n    // the segment before and after it in the great circle\n    const markerFeatures = markerBasis.map((arc) => arc.coords.map((arcpoint, i) => {\n      const start = arc.coords[Math.max(0, i - 1)];\n      const end = arc.coords[Math.min(i + 1, arc.length - 1)]\n      const angle = - getRotation([start, end]);\n\n      // fixed length line through the arcpoint at the angle\n      const scale = 0.3;\n      const markerLine = new LineString([\n          [arcpoint[0] - scale*Math.sin(angle), arcpoint[1] - scale*Math.cos(angle) ],\n          [arcpoint[0] + scale*Math.sin(angle), arcpoint[1] + scale*Math.cos(angle) ],\n        ]);\n\n      // TODO add text with rotation\n\n      // TODO add labels\n      return new Feature({\n        geometry: markerLine,\n        label: markerEvery * i,\n        rotation: angle+Math.PI/2\n      })\n    })).flat();\n\n\n    // TODO improve performance by manipulating collection?\n    this.greatCircleSource.clear();\n\n    // the first one is the view line: set arrow\n    newFeatures[0].setStyle(arrowStyle);\n    this.greatCircleSource.addFeatures(newFeatures);\n    this.greatCircleSource.addFeatures(markerFeatures);\n  }\n\n  componentDidMount = () => {\n\n    const draw = new Draw({\n      source: this.pointSource,\n      type: 'LineString',\n      maxPoints: 2\n    });\n\n    draw.on('drawstart', () => {\n      this.pointSource.clear();\n      this.greatCircleSource.clear();\n    });\n\n    const view = new View({\n      center: [0, 0],\n      zoom: 3,\n      projection: viewProjection,\n    });\n\n    view.on('change:resolution', this.generateGreatCircle);\n    this.pointSource.on(['addfeature', 'changefeature'], this.generateGreatCircle);\n\n    this.map = new Map({\n      layers: [\n        new TileLayer({\n          source: new XYZ({\n            // mapbox: doesn't always have level 18\n      //      url: 'https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=qu62rKisigsebPda2e6b',\n            url: \"https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=Dy8GRe9OwAAQHfnhr24y\",\n            attributions: '<a href=\"https://www.maptiler.com/copyright/\" target=\"_blank\">&copy; MapTiler</a>',\n            tileSize: 256,\n            maxZoom: 20,\n            crossOrigin: 'anonymous',\n          }),\n        }),\n        new VectorLayer({ source: this.greatCircleSource, style: circleStyleFunction }),\n        new VectorLayer({ source: this.pointSource, style: [] }),\n      ],\n      target: 'map',\n      view: view,\n      interactions: defaultInteractions().extend([\n        new Modify({ source: this.pointSource, insertVertexCondition: never }),\n        draw,\n        new Snap({source: this.pointSource }) ]),\n    });\n  }\n\n  render = () => {\n    return (\n      <div id=\"map\">\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}