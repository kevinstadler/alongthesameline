{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["circleStyle","VectorLayer","getStyle","getStroke","setWidth","setColor","oneDegreeDistance","getDistance","projectionCache","getStereographicProjection","center","projName","proj4","defs","register","getProjection","distanceString","distance","dim","Math","floor","log10","round","circleStyleFunction","feature","resolution","get","setText","Text","stroke","font","text","rotation","rotateWithView","offsetX","getRotation","points","dx","dy","atan2","arrowStyle","geom","getGeometry","getCoordinates","length","Style","geometry","Point","image","RegularShape","radius","angle","PI","getImage","App","props","fitGreatCircle","numSegments","GreatCircle","x","y","Arc","offset","geometries","generateGreatCircle","antipodes","map","sign","pointGroups","extent","getView","calculateExtent","unitsPerPixel","getWidth","getSize","nSegments","c","sqrt","pow","d","min","max","ceil","metersPerPixel","i","arc","Feature","LineString","coords","fromLonLat","flat","getMetersPerUnit","markerEvery","segmentLength","nSegmentsToGetOneEveryMarker","arcpoint","start","end","markerLine","sin","cos","label","addLines","pointSource","getFeatures","greatCircleSource","clear","toLonLat","arrowCoords","addFeature","style","verticalDegrees","point","recenteredProjection","circlePoints","Array","from","rotate","componentDidMount","draw","Draw","source","type","maxPoints","on","view","View","zoom","projection","Map","layers","TileLayer","OSM","target","interactions","defaultInteractions","extend","Modify","insertVertexCondition","never","Snap","render","id","VectorSource","React","Component","Boolean","window","location","hostname","match","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.a3619b01.chunk.js","sourcesContent":["import React from 'react';\nimport './App.css';\nimport 'ol/ol.css';\n\nimport Map from 'ol/Map.js';\nimport View from 'ol/View.js';\n\nimport {defaults as defaultInteractions, DragRotateAndZoom, Draw, Modify, Snap} from 'ol/interaction';\nimport {never} from 'ol/events/condition';\n\nimport {Tile as TileLayer, Vector as VectorLayer} from 'ol/layer';\nimport {OSM, Vector as VectorSource, XYZ} from 'ol/source';\nimport Feature from 'ol/Feature';\nimport Point from 'ol/geom/Point';\nimport LineString from 'ol/geom/LineString';\nimport {Fill, Stroke, Circle, Style} from 'ol/style';\nimport Text from 'ol/style/Text';\nimport RegularShape from 'ol/style/RegularShape';\nimport {rotate} from 'ol/coordinate';\n\nimport {GreatCircle} from 'arc';\nimport {getDistance} from 'ol/sphere';\nimport {get as getProjection, fromLonLat, toLonLat} from 'ol/proj.js';\nimport {containsExtent, getHeight, getWidth} from 'ol/extent';\nimport {register} from 'ol/proj/proj4';\nimport proj4 from 'proj4';\n\n// TODO change to 3857 but this will require WHAT\nconst viewProjection = 'EPSG:4326';\n\nconst circleStyle = new VectorLayer().getStyle()()[0];\ncircleStyle.getStroke().setWidth(1.75);\ncircleStyle.getStroke().setColor('#0000cc');\n\nconst oneDegreeDistance = getDistance([0, 0], [0, 1]);\n\nconst projectionCache = {};\nconst getStereographicProjection = (center) => {\n  center = center || [0, 0];\n  const projName = 'StandardProj' + center[0] + '/' + center[1];\n  if (!projectionCache[projName]) {\n    proj4.defs(projName, '+proj=stere +lat_0=' + center[1] + ' +lon_0=' + center[0] + ' +k=1 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs');\n    register(proj4);\n    projectionCache[projName] = getProjection(projName);\n  }\n  return(projectionCache[projName]);\n}\n\nconst distanceString = (distance) => {\n  const dim = Math.floor(Math.log10(distance)) - 1;\n//  const num = Math.round(distance / Math.pow(10, dim));\n  if (dim < 3) {\n    return Math.round(distance) + 'm';\n  } else if (dim < 6) {\n    return Math.round(distance / 1000) + 'km';\n  } else if (dim < 9) {\n    return Math.round(distance / 1000000) + 'k km';\n  } else {\n    return Math.round(distance / 1000000) + 'mio km';\n  }\n}\n\nconst circleStyleFunction = (feature, resolution) => {\n  if (feature.get('label')) {\n    circleStyle.setText(new Text({\n      stroke: circleStyle.getStroke(),\n//      fill: circleStyle.getFill(),\n      font: '12px sans-serif',\n      text: feature.get('label'),\n      rotation: feature.get('rotation'),\n      rotateWithView: true,\n      offsetX: 25,\n    }));\n  }\n  return circleStyle;\n}\n\nconst getRotation = (points) => {\n  const dx = points[0][0] - points[1][0];\n  const dy = points[0][1] - points[1][1];\n  return Math.atan2(dy, dx);\n}\n\nconst arrowStyle = (feature) => {\n  const geom = feature.getGeometry().getCoordinates();\n  const rotation = getRotation([geom[geom.length - 1], geom[geom.length - 2]]);\n  return [\n    circleStyle,\n    new Style({\n      geometry: new Point(geom[geom.length - 1]),\n      image: new RegularShape({\n        stroke: circleStyle.getStroke(),\n        points: 3,\n        radius: 8,\n        rotation: -rotation,\n//        displacement: [ -4 * Math.sin(rotation), 4 * Math.cos(rotation) ],\n        angle: Math.PI / 2\n      })\n    }),\n    new Style({\n      geometry: new Point(geom[0]),\n      image: circleStyle.getImage()\n    })\n  ];\n}\n\nclass App extends React.Component {\n\n  constructor(props) {\n    super(props);\n\n    this.pointSource = new VectorSource();\n    this.greatCircleSource = new VectorSource();\n  }\n\n  fitGreatCircle = (points, numSegments) => {\n    // TODO catch TypeError/Error when two points are antipodal\n    const generator = new GreatCircle({ x: points[0][0], y: points[0][1] }, { x: points[1][0], y: points[1][1] });\n    return generator.Arc(numSegments, { offset: 0.1 }).geometries; // 1 or more arc segments (split at +-180deg)\n  }\n\n  generateGreatCircle = (points) => {\n    const antipodes = points.map(([x, y]) => [x - 180*Math.sign(x), -y]);\n    const pointGroups = [\n      points,\n      [ points[1], antipodes[0] ],\n      antipodes,\n      [ antipodes[1], points[0] ],\n    ];\n    // TODO skip segments which aren't visible in the current view\n\n    // in projection coordinates (because number of segments will depend on pixels)\n    const extent = this.map.getView().calculateExtent();\n    const unitsPerPixel = getWidth(extent) / this.map.getSize()[0];\n\n    // TODO calculate great circle distance between those points, and choose number of segments accordingly?\n    const pixelDistances = pointGroups.map((c) => Math.sqrt(\n      Math.pow(c[0][0] - c[1][0], 2)\n      + Math.pow(c[0][1] - c[1][1], 2)) / unitsPerPixel);\n    // don't leave the 1, 1000 segment range\n    const nSegments = pixelDistances.map((d) => Math.min(1000, Math.max(1, Math.ceil(d / 20))));\n\n    const newFeatures = pointGroups.map((points, i) => {\n      return this.fitGreatCircle(points, nSegments[i]).map((arc) => new Feature({\n        geometry: new LineString(arc.coords.map((c) => fromLonLat(c, viewProjection)))\n  //        style: new Style(),\n      }));\n    }).flat();\n\n    const metersPerPixel = unitsPerPixel * this.map.getView().getProjection().getMetersPerUnit();\n    // draw a distance marker every 10 pixels\n    var markerEvery = Math.ceil(Math.log10(10 * metersPerPixel));\n    // convert to meters\n    markerEvery = Math.pow(10, markerEvery); // TODO allow markers at 5s as well as 1s\n    // TODO find currently visible segment from the previously fit great circles, then\n    // 1. find 90degree (or smaller) point, figure out how many segments would produce points\n    // at every required multiple of meters\n    const segmentLength = getDistance(pointGroups[1][1], pointGroups[1][0]); // point to antipode\n    const nSegmentsToGetOneEveryMarker = Math.ceil(segmentLength / markerEvery);\n    const markerBasis = this.fitGreatCircle(pointGroups[1], nSegmentsToGetOneEveryMarker);\n    // 2. fit a new, short 1-segment linestring through every of those points, at the mean angle of\n    // the segment before and after it in the great circle\n    const markerFeatures = markerBasis.map((arc) => arc.coords.map((arcpoint, i) => {\n      const start = arc.coords[Math.max(0, i - 1)];\n      const end = arc.coords[Math.min(i + 1, arc.length - 1)]\n      const angle = - getRotation([start, end]);\n\n      // fixed length line through the arcpoint at the angle\n      const scale = 0.3;\n      const markerLine = new LineString([\n          [arcpoint[0] - scale*Math.sin(angle), arcpoint[1] - scale*Math.cos(angle) ],\n          [arcpoint[0] + scale*Math.sin(angle), arcpoint[1] + scale*Math.cos(angle) ],\n        ]);\n\n      // TODO add text with rotation\n\n      // TODO add labels\n      return new Feature({\n        geometry: markerLine,\n        label: distanceString(markerEvery * i),\n        rotation: angle+Math.PI/2\n      })\n    })).flat();\n\n    // TODO return\n  }\n\n  addLines = () => {\n    if (this.pointSource.getFeatures().length == 0) {\n      return;\n    }\n\n    this.greatCircleSource.clear();\n\n    // in projection coordinates (because number of segments will depend on pixels)\n    const extent = this.map.getView().calculateExtent();\n\n    const points = this.pointSource.getFeatures()[0].getGeometry().getCoordinates().map((c) => toLonLat(c, viewProjection));\n\n    const arrowCoords = this.fitGreatCircle(points, 10)[0].coords.map((c) => fromLonLat(c, viewProjection));\n    this.greatCircleSource.addFeature(new Feature({\n      geometry: new LineString(arrowCoords),\n      // the first one is the view line: set arrow\n      style: arrowStyle\n    }));\n\n\n    // draw the circle\n    if (true) {\n      const distance = getDistance(points[0], points[1]);\n      const verticalDegrees = distance / oneDegreeDistance;\n      const nPoints = 100;\n      const point = fromLonLat([0, verticalDegrees], getStereographicProjection());\n      const recenteredProjection = getStereographicProjection(points[0]);\n      const circlePoints = Array.from({length: nPoints}, (x, i) => {\n        rotate(point, 2 * Math.PI / nPoints);\n        // TODO translate/reproject!?\n        return toLonLat(point, recenteredProjection);\n      });\n      this.greatCircleSource.addFeature(new Feature({ geometry: new LineString([...circlePoints, circlePoints[0]]), label: distanceString(distance) }));\n    }\n\n\n    // draw the lines\n    if (false) {\n      const features = this.generateGreatCircle(points);\n      // TODO improve performance by manipulating collection?\n//      this.greatCircleSource.addFeatures(newFeatures);\n//      this.greatCircleSource.addFeatures(markerFeatures);\n    }\n\n  }\n\n  componentDidMount = () => {\n\n    const draw = new Draw({\n      source: this.pointSource,\n      type: 'LineString',\n      maxPoints: 2\n    });\n\n    draw.on('drawstart', () => {\n      this.pointSource.clear();\n      this.greatCircleSource.clear();\n    });\n\n    const view = new View({\n      center: [0, 0],\n      zoom: 3,\n      projection: viewProjection,\n    });\n\n    view.on('change:resolution', this.addLines);\n    this.pointSource.on(['addfeature', 'changefeature'], this.addLines);\n\n    this.map = new Map({\n      layers: [\n        new TileLayer({\n          source: new OSM(), //new XYZ({\n      //       // mapbox: doesn't always have level 18\n      // //      url: 'https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=qu62rKisigsebPda2e6b',\n      //       url: \"https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=Dy8GRe9OwAAQHfnhr24y\",\n      //       attributions: '<a href=\"https://www.maptiler.com/copyright/\" target=\"_blank\">&copy; MapTiler</a>',\n      //       tileSize: 256,\n      //       maxZoom: 20,\n      //       crossOrigin: 'anonymous',\n      //     }),\n        }),\n        new VectorLayer({ source: this.greatCircleSource, style: circleStyleFunction }),\n        new VectorLayer({ source: this.pointSource, style: [] }),\n      ],\n      target: 'map',\n      view: view,\n      interactions: defaultInteractions().extend([\n        new Modify({ source: this.pointSource, insertVertexCondition: never }),\n        draw,\n        new Snap({source: this.pointSource }) ]),\n    });\n  }\n\n  render = () => {\n    return (\n      <div id=\"map\">\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}